trigger:
  branches:
    include:
      - main
      - dev
  paths:
    include: [ app/*, frontend/*, infra/*, Dockerfile, azure-pipelines.yml ]

pool:
  # name: 'Default'
  vmImage: 'ubuntu-latest'

variables:
  # Nombres de las conexiones (Asegúrate que coincidan con lo que creaste en Project Settings)
  dockerConnection: 'DockerHubConn' 
  azureConnection: 'AzureRMConn' 

  # Nombre de la imagen y app
  imageName: 'fastapi-react-unified'
  baseAppName: 'app-unified'

  # Variables del proyecto
  projectSuffix: 'demo1'
  
  # Lógica condicional para variables de entorno
  ${{ if eq(variables['Build.SourceBranchName'], 'main') }}:
    environmentName: 'prod'
    tfStateKey: 'prod.terraform.tfstate' # Estado Terraform separado para Prod
  ${{ if ne(variables['Build.SourceBranchName'], 'main') }}:
    environmentName: 'dev'
    tfStateKey: 'dev.terraform.tfstate' # Estado Terraform separado para Dev

stages:
# STAGE 1: BUILD & PUSH (UNIFICADO)
- stage: Build
  displayName: 'Build Unified Image'
  jobs:
  - job: BuildUnified
    displayName: 'Build Full Stack'
    steps:
    - task: Docker@2
      displayName: 'Build & Push Docker Image'
      inputs:
        containerRegistry: $(dockerConnection)
        repository: $(dockerId)/$(imageName)
        command: 'buildAndPush'
        # Usamos el Dockerfile de la raíz
        Dockerfile: 'Dockerfile' 
        # IMPORTANTE: El contexto debe ser la raíz (.) para ver /app y /frontend
        buildContext: '.' 
        tags: |
          latest
          $(Build.BuildId)

# STAGE 2: INFRASTRUCTURE
- stage: Infrastructure
  displayName: 'Deploy Infra ($(environmentName))'
  dependsOn: Build
  jobs:
  - job: Terraform
    steps:
    - task: TerraformInstaller@1
      inputs: { terraformVersion: 'latest' }
    
    - task: TerraformTaskV4@4
      displayName: 'TF Init'
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
        backendServiceArm: '$(azureConnection)'
        backendAzureRmResourceGroupName: '$(tfStateRg)'
        backendAzureRmStorageAccountName: '$(tfStateStorageAccount)'
        backendAzureRmContainerName: '$(tfStateContainer)'
        backendAzureRmKey: '$(tfStateKey)'

    - task: TerraformTaskV4@4
      displayName: 'TF Apply'
      inputs:
        provider: 'azurerm'
        command: 'apply'
        workingDirectory: '$(System.DefaultWorkingDirectory)/infra'
        environmentServiceNameAzureRM: '$(azureConnection)'
        # Quitamos la variable frontend_image
        commandOptions: '-auto-approve -var "environment=$(environmentName)" -var "project_suffix=$(projectSuffix)" -var "backend_image=$(dockerId)/$(imageName):latest" -var "db_pass=$(DB_PASSWORD)"'
      env:
        DB_PASSWORD: $(DB_PASSWORD)

# STAGE 3: DEPLOY
- stage: Deploy
  displayName: 'Update App'
  dependsOn: Infrastructure
  jobs:
  - job: DeployApp
    steps:
    - task: AzureContainerApps@1
      displayName: 'Deploy Unified App'
      inputs:
        azureSubscription: '$(azureConnection)'
        imageToDeploy: '$(dockerId)/$(imageName):$(Build.BuildId)'
        containerAppName: '$(baseAppName)-$(projectSuffix)-$(environmentName)'
        resourceGroup: 'rg-fastapi-$(projectSuffix)-$(environmentName)'
